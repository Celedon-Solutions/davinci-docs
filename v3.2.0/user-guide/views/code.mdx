---
title: Code View
---

## Description  
The Code View allows users to edit specific fields and structures of code objects beyond their base properties. This view consists of two panes: the left pane contains the code editor, while the right pane serves as the output terminal.  

<Frame>
    <img height="400" noZoom src="/images/Code.png" />  
</Frame>



## Code Editor  
The code editor enables you to modify code, and all changes are automatically saved as you edit.  

<Note>During live collaboration, only one user can edit a given line of code at a time.</Note>

To execute a code object, first select the function to run in the code from the dropdown menu, then click the `Run` button in the top-right corner of the header bar. At any time you can halt execution by hitting the `Stop` button.

<Info>By default, the output window is closed. It automatically opens when code is executed and can be toggled using the `Output` button on the right side of the header bar.</Info>

<Note>The output terminal does not retain data. It resets when the workspace tab is closed or when the same code is rerun.</Note>
{/* 
### Davinci Editing
You can use Davinci to make inline edits by selecting a range of code. Once selected a popup will appear and selecting the edit icon will make a input window open to allow instructions to edit specific areas of the code.

<Frame>
<img height="400" noZoom src="/images/Code_editing.png" /> 
</Frame>

Normally the edits will consider the code selected and its context in the object. To consider other information you can add reference objects using the add reference button to the right of the input box.

While the selection will be the focus of the edits, Davinci can edit any code in the object based on the instruction. */}

### Output Terminal
The output will display any prints or plots. If errors occur they will also be displayed here. 

<Note>You must use `plt.show` in your code to generate your plots in the output.</Note>  

Plots and images generated by the Code can be saved to your Project by clicking the `Save Figure` Button beneath each figure. If no destination is provided, it will be saved at the root of the Library Index.

### Referencing Model Objects
You can reference values from model objects within the code using `@` or other script-based methods. When attributes are referenced, only the resolved values are passed into the compiled code.  

<Note>In these docs `[@object]` will denote the reference anchor of the object you want to import. Use `@` to reference the object in the code and it will place an anchor at the location of the caret.</Note>
```python unit_reference.py
    varBase = [@object]
    varConverted = [@object]("mg")
``` 
If the object is `1 kg` in the model then `varBase` will be `1` and `varConverted` will be `1000000` because of the `mg` conversion.

<Note>Once assigned sto a varaible you can not do any other unit conversions via `("unit")` notation. The value is a number which is converted on run of the code getting the database value at the time of the run.</Note>

### Working with Attributes

```python unit_conversion.py
    # Get mass in grams (converts from whatever unit is stored)
    mass_in_grams = [<@object ref>]("g")
```

```python density_calc.py
    # Get volume and mass, then calculate density
    volume = [<@object ref>]("m^3")
    mass = [<@object ref>]("kg")
    density = mass / volume
    print(f"Density: {density} kg/m^3")
```

```python string_attribute.py
    # Get a material name attribute (ignore unit specification)
    material_name = [<@object ref>]
    print(f"Material: {material_name}")
```

```python properties_dict.py
    # Dictionary with name, value, unit fields using proper UUID loading
    beam_properties = {
        "length": {
            "name": "Beam Length",
            "value": [<@object ref>]("mm"),
            "unit": "mm"
        },
        "width": {
            "name": "Beam Width", 
            "value": [<@object ref>]("mm"),
            "unit": "mm"
        },
        "load": {
            "name": "Applied Load",
            "value": [<@object ref>]("N"),
            "unit": "N"
        },
        "material_strength": {
            "name": "Material Yield Strength",
            "value": [<@object ref>]("MPa"),
            "unit": "MPa"
        }
    }
```

#### Working with Units from the Model
Use standard units for conversions and calculations (for example: `mm`, `kg`, `m^3`, `degC`). For the complete and up-to-date list of supported units and prefixes, see the Units reference: [/v3.0.1/modeling/common/units](/v2.0.0/modeling/common/units).

### Update Model Objects
You can update model attributes by calling the `update_attribute()` function.

```python update_object.py
    var = 1000
    unit = "kg";
    kind = "number";
    update_attribute([@object], var, unit, kind)
```
This will update the object in the model with the new value and unit passed in. For unitless values you can ignore the unit parameter. For constraints you can ignore the unit and kind parameters. 

<Note>The `update_attribute` function will only work on `Attribute` and `Constraint` objects. Kind must be an allowed kind type. See the [Model Object Types](/v3.0.1/modeling/common/equations#value-types) for more information.</Note>

<Warning>You must use proper unit type when converting or an error will occur in the resolved value.</Warning>

### Saving and Loading Files
You can save files to the model by calling the `davinci_save_file()` function.

```python save_file.py
    davinci_save_file("test", "File.txt")
```
This will save the string `test` to the file `File.txt` which is under the object at the start of the path from the project database. It will be a .txt type object.

When using files paths any named paths are defined starting from the code object's location. You can use `[@object]` to start the location path from other locations in the project.

<Note>You can use named paths to traverse package objects to find files in the database. You can NOT use `../` to traverse upwards.</Note>

You can load refernece files from the model by calling the `davinci_open_file()` function.

```python load_file.py
    content = davinci_open_file("<uuid_string>", "r")
```
This example opens the file `File.txt` which is under the object at the start of the path from the project database. 

<Note>Any `[@object]` must be package objects. This means that the object must be a package object or a package object must be referenced in the path.</Note>

### Importing Local Code
<Note>[@object] is the reference anchor of the object you want to import. Use `@` to reference the object in the code.</Note>
```python importing.py
    import [@object]
``` 

Here's an example of how two code objects can interact.

**Code Object 1 (e.g., `utils.py`):**
```python utils.py
def say_hello():
    return "Hello from utils!"
```

**Code Object 2 (e.g., `main.py`):**
```python main.py
import [@utils] 

message = say_hello()
print(message) # Output: Hello from utils!
```
In this setup, `main.py` imports `utils.py` (referenced as `[@utils]`) and can then use the functions defined within it, like `say_hello()`.

<Note>The imports will expose all functions to the globals at the moment.</Note>

### Python modules

<Note>Only a few packages can be used in browser at this time.</Note>

Below is a list of the base Python packages loaded and available for use:

| Package Name        | Notes |
|---------------------|-------|
| Pillow              |       |
| contourpy           |       |
| cycler              |       |
| fonttools           |       |
| kiwisolver          |       |
| packaging           |       |
| pyparsing           |       |
| python-dateutil     |       |
| pytz                |       |
| six                 |       |
| numpy               |       |
| matplotlib          |   imported as `plt`     |
| openblas            |       |
| scipy               |       |
| httpx               |       |


